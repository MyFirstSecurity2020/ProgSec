# 2-4.Linux 執行檔分析:objdump
- objdump:display information from object files

- 兩大常用用途
  - 1.ELF 分析
  - 2.objdump逆向分析
- 常用指令參數
- 更多指令參數請參閱 https://man7.org/linux/man-pages/man1/objdump.1.html

## 學習資源


# 1.ELF 分析
- 指令參數
```
-h	顯示區段頭section headers
-g	顯示除錯資訊
-l	顯示行號資訊
-p	顯示專有檔頭資訊，具體內容取決於檔案格式
-f	顯示檔案檔頭
-r 	顯示重定資訊
-R 	顯示動態連結重定資訊
-s 	顯示檔案所有內容
-W	顯示檔案中包含有DWARF 除錯資訊格式的區段
-t	顯示檔案的符號表
-T 	顯示動態連結符號表
-x 	顯示檔案的所有檔頭 --all header
```
#### 範例
- 原始碼:helloCTFer.c
```c
#include <stdio.h>

int main()
{
   printf("Hello CTFer\n ”);
   return 0;
}
```
# 2.objdump逆向分析

- 指令參數
```
-d  --disassemble
    從objfile中對機器指令進行反彙編。本選項只對那些包含指令的section進行反彙編。

-D  --disassemble-all
    類似於-d，但是本選項會對所有的sections進行反彙編，而不僅僅是那些包含指令的sections。
    本選項會微妙的影響程式碼片段的反彙編。當使用-d選項的時候，objdump會假設代碼中出現的所有symbols都在對應
    的boundary範圍之內，並且不會跨boundary來進行反彙編； 而當使用-D選項時，則並不會有這樣的假設。這就
    意味著-d與-D選項在反彙編時，可能輸出結果會有些不同，比如當資料存放在程式碼片段的情況下。

-S 	顯示原始碼和反組譯程式碼(包含－d 參數)

--prefix-addresses
    反彙編的時候，顯示每一行的完整位址。這是一種比較老的反彙編格式
```
#### 範例1
- 編譯 gcc -o helloCTFer helloCTFer.c  -g
- 反編譯1(使用att格式) ==> objdump -S helloCTFer  (預設:使用AT&T語法)  [結果1](objdump_s_1.md)
- 反編譯2(使用att格式) ==>objdump -S -M att helloCTFer [結果2](objdump_s_2.md)
- 反編譯3(使用intel格式) ==>objdump -S -M intel helloCTFer [結果3](objdump_s_3.md)
- 反編譯4 ==> objdump -S `-j .text` -M intel helloCTFer [結果4](objdump_s_4.md)
- 反編譯5 ==> objdump -S -j .text -M intel helloCTFer --no-show-raw-insn  [結果5](objdump_s_5.md)
  - 不顯示機器指令 ==> --no-show-raw-insn 

#### 範例2
- 原始碼 add2.c
```c
#include <stdio.h>

int add(int x, int y)
{
  int sum = 0;
  sum += x;
  sum += y;
  return sum;
}

int main()
{
  int a = 2, b = 3;
  printf("%d\n",add(a, b) );
  return 0;
}
```
- 編譯 gcc -o add2 add2.c  -g
- 反編譯(使用intel格式) ==> objdump -D `-M intel` add2
- 反編譯(使用intel格式+ 只要執行區段.text) ==> objdump -D -M intel -j .text add2
- 反編譯 ==> objdump -D -M intel -j .text add2 --no-show-raw-insn
- 反編譯 ==> objdump -S -M intel -j .text add2 --no-show-raw-insn 

```c
000000000000064a <add>:
#include <stdio.h>

int add(int x, int y)
{
 64a:	push   rbp
 64b:	mov    rbp,rsp
 64e:	mov    DWORD PTR [rbp-0x14],edi
 651:	mov    DWORD PTR [rbp-0x18],esi
  int sum = 0;
 654:	mov    DWORD PTR [rbp-0x4],0x0
  sum += x;
 65b:	mov    eax,DWORD PTR [rbp-0x14]
 65e:	add    DWORD PTR [rbp-0x4],eax
  sum += y;
 661:	mov    eax,DWORD PTR [rbp-0x18]
 664:	add    DWORD PTR [rbp-0x4],eax
  return sum;
 667:	mov    eax,DWORD PTR [rbp-0x4]
}
 66a:	pop    rbp
 66b:	ret    


000000000000066c <main>:

int main()
{
 66c:	push   rbp
 66d:	mov    rbp,rsp
 670:	sub    rsp,0x10
  int a = 2, b = 3;
 674:	mov    DWORD PTR [rbp-0x8],0x2
 67b:	mov    DWORD PTR [rbp-0x4],0x3
  printf("%d\n",add(a, b) );
 682:	mov    edx,DWORD PTR [rbp-0x4]
 685:	mov    eax,DWORD PTR [rbp-0x8]
 688:	mov    esi,edx
 68a:	mov    edi,eax
 68c:	call   64a <add>
 691:	mov    esi,eax
 693:	lea    rdi,[rip+0x9a]        # 734 <_IO_stdin_used+0x4>
 69a:	mov    eax,0x0
 69f:	call   520 <printf@plt>
  return 0;
 6a4:	mov    eax,0x0
}
 6a9:	leave  
 6aa:	ret    
 6ab:	nop    DWORD PTR [rax+rax*1+0x0]


```
